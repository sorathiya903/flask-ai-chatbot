<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Interactive 3D Galaxy</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<style>
    body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
    #video-container { position: fixed; bottom: 20px; right: 20px; width: 180px; height: 130px; border: 2px solid #555; border-radius: 8px; overflow: hidden; transform: scaleX(-1);}
    #input_video { width: 100%; height: 100%; object-fit: cover; }
    #ui { position: fixed; top: 20px; left: 20px; color: white; pointer-events: none; }
    .guide { font-size: 0.8rem; margin-top: 5px; color: #aaa; }
    #status { color: #00ffcc; font-weight: bold; margin-top: 10px; }
</style>
</head>
<body>

<div id="ui">
    <h2>3D Gesture Galaxy</h2>
    <div class="guide">ü§è Pinch: Change Particle Color</div>
    <div class="guide">‚òùÔ∏è Index Finger Only: Morph to Cube</div>
    <div class="guide">‚úåÔ∏è Three Fingers: Slow Rotation</div>
    <div class="guide">‚ÜîÔ∏è Move Hand: Move Particles</div>
    <div class="guide">Blink Eyes: Change Background</div>
    <div id="status">Starting Camera...</div>
</div>

<div id="video-container">
    <video id="input_video"></video>
</div>

<script>
const particleCount = 5000;
let scene, camera, renderer, points, geometry;
let currentShape = 'sphere';
const videoElement = document.getElementById('input_video');
const statusText = document.getElementById('status');

// Rotation speeds
let rotationSpeedY = 0.005;
let rotationSpeedX = 0.002;
const defaultY = 0.005;
const defaultX = 0.002;
const slowY = 0.001;
const slowX = 0.0005;

// Particle offset for hand movement
let offsetX = 0, offsetY = 0;

// Store initial particle positions
let originalPositions;

// Dark background colors
const darkColors = ["red","black","blue","white","green","tomato"];

// Initialize Three.js
function initThree(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight,0.1,2000);
    camera.position.z = 500;

    renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount*3);
    const colors = new Float32Array(particleCount*3);
    originalPositions = new Float32Array(particleCount*3);

    for(let i=0;i<particleCount;i++){
        const {x,y,z} = randomPointInSphere(250);
        positions[i*3] = x;
        positions[i*3+1] = y;
        positions[i*3+2] = z;

        originalPositions[i*3] = x;
        originalPositions[i*3+1] = y;
        originalPositions[i*3+2] = z;

        colors[i*3] = Math.random();
        colors[i*3+1] = Math.random();
        colors[i*3+2] = Math.random();
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors,3));

    const material = new THREE.PointsMaterial({
        size:3,
        vertexColors:true,
        transparent:true,
        opacity:0.8
    });

    points = new THREE.Points(geometry, material);
    scene.add(points);
}

// Helper function: random point inside a sphere
function randomPointInSphere(radius){
    const u = Math.random();
    const v = Math.random();
    const theta = 2 * Math.PI * u;
    const phi = Math.acos(2*v - 1);
    const r = Math.cbrt(Math.random()) * radius;
    return {
        x: r * Math.sin(phi) * Math.cos(theta),
        y: r * Math.sin(phi) * Math.sin(theta),
        z: r * Math.cos(phi)
    };
}

// Morph between sphere and cube
function updateShape(target){
    if(currentShape === target) return;
    currentShape = target;
    const positions = geometry.attributes.position.array;

    for(let i=0;i<particleCount;i++){
        if(target==='cube'){
            positions[i*3] = (Math.random()-0.5)*300 + offsetX;
            positions[i*3+1] = (Math.random()-0.5)*300 + offsetY;
            positions[i*3+2] = (Math.random()-0.5)*300;
        }else{
            const {x,y,z} = randomPointInSphere(250);
            positions[i*3] = x + offsetX;
            positions[i*3+1] = y + offsetY;
            positions[i*3+2] = z;
        }
    }
    geometry.attributes.position.needsUpdate = true;
}

// EAR calculation for blink detection
function getEAR(landmarks,leftIndices,rightIndices){
    function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
    const leftEAR=(dist(landmarks[leftIndices[1]],landmarks[leftIndices[5]])+
                   dist(landmarks[leftIndices[2]],landmarks[leftIndices[4]]))/
                  (2*dist(landmarks[leftIndices[0]],landmarks[leftIndices[3]]));
    const rightEAR=(dist(landmarks[rightIndices[1]],landmarks[rightIndices[5]])+
                   dist(landmarks[rightIndices[2]],landmarks[rightIndices[4]]))/
                  (2*dist(landmarks[rightIndices[0]],rightIndices[3]));
    return (leftEAR+rightEAR)/2;
}

// Hand gesture logic
function onResultsHands(results){
    if(results.multiHandLandmarks && results.multiHandLandmarks.length>0){
        const hand = results.multiHandLandmarks[0];
        let actionText = "Tracking Hand...";

        // Particle offset based on hand
        offsetX = (hand[0].x-0.5)*800;
        offsetY = -(hand[0].y-0.5)*600;

        // Zoom logic (optional)
        const dx = hand[0].x - hand[12].x;
        const dy = hand[0].y - hand[12].y;
        const handSize = Math.sqrt(dx*dx + dy*dy);
        const targetZ = 800 - (handSize*1200);
        camera.position.z += (targetZ - camera.position.z)*0.1;

        // Pinch: change particle color
        const pinchDist = Math.hypot(hand[4].x-hand[8].x, hand[4].y-hand[8].y);
        if(pinchDist<0.04){
            const colors = geometry.attributes.color.array;
            const r=Math.random(), g=Math.random(), b=Math.random();
            for(let i=0;i<colors.length;i+=3){ colors[i]=r; colors[i+1]=g; colors[i+2]=b; }
            geometry.attributes.color.needsUpdate = true;
            actionText="Change Color";
        }

        // Shape gestures
        const isIndexUp = hand[8].y<hand[6].y;
        const isMiddleUp = hand[12].y<hand[10].y;
        const isRingUp = hand[16].y<hand[14].y;
        const isPinkyUp = hand[20].y<hand[18].y;

        if(isIndexUp && !isMiddleUp && !isRingUp && !isPinkyUp){
            updateShape('cube');
            actionText="Morph to Cube";
        }else{
            updateShape('sphere');
        }

        // Rotation speed gestures
        if(isIndexUp && isMiddleUp && isRingUp && !isPinkyUp){
            rotationSpeedY=slowY;
            rotationSpeedX=slowX;
            actionText="Slow Rotation";
        }else{
            rotationSpeedY=defaultY;
            rotationSpeedX=defaultX;
        }

        statusText.innerText="Action: "+actionText;
    }else{
        statusText.innerText="Hand not detected";
    }
}

// Initialize Three.js
initThree();

// Setup Hands
const hands = new Hands({locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
hands.onResults(onResultsHands);

// Setup Face Mesh for blink
const faceMesh = new FaceMesh({locateFile:(file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
faceMesh.setOptions({maxNumFaces:1, refineLandmarks:true, minDetectionConfidence:0.5, minTrackingConfidence:0.5});
faceMesh.onResults((results)=>{
    if(results.multiFaceLandmarks && results.multiFaceLandmarks.length>0){
        const landmarks = results.multiFaceLandmarks[0];
        const leftEye=[33,160,158,133,153,144];
        const rightEye=[362,385,387,263,373,380];
        const ear = getEAR(landmarks,leftEye,rightEye);
        if(ear<0.2){
            const color = darkColors[Math.floor(Math.random()*darkColors.length)];
            scene.background = new THREE.Color(color);
        }
    }
});

// Camera input
const cameraInput = new Camera(videoElement,{
    onFrame: async ()=>{ await hands.send({image:videoElement}); await faceMesh.send({image:videoElement}); },
    width:640, height:480
});
cameraInput.start();

// Animation loop
function animate(){
    requestAnimationFrame(animate);
    points.rotation.y += rotationSpeedY;
    points.rotation.x += rotationSpeedX;

    // Move particles smoothly according to hand
    const positions = geometry.attributes.position.array;
    for(let i=0;i<particleCount;i++){
        positions[i*3] = originalPositions[i*3] + offsetX*0.2;
        positions[i*3+1] = originalPositions[i*3+1] + offsetY*0.2;
    }
    geometry.attributes.position.needsUpdate = true;

    renderer.render(scene,camera);
}

window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
animate();
</script>
</body>
</html>
